import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib as mpl
import joblib
import pickle
import mordred
from mordred import Calculator, descriptors
from typing import * # import all the type hints (wildcard import)
import tqdm  # type: ignore (this is connected with the progress bar _pbar)
import rdkit
from rdkit.DataStructs.cDataStructs import BulkTanimotoSimilarity, TanimotoSimilarity  # type: ignore
import exmol as exmol
from stoned import stoned
import selfies as sf  # type: ignore
# from rdkit.Chem.Draw import rdDepictor
# import os
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
# from sklearn.metrics import roc_auc_score, plot_roc_curve
# from sklearn.multioutput import MultiOutputRegressor
# from sklearn.linear_model import Ridge

from spectrum_func import *

def get_basic_alphabet() -> Set[str]:
    """Returns set of interpretable SELFIES tokens

    Generated by removing P and most ionization states from :func:`selfies.get_semantic_robust_alphabet`

    :return: Set of interpretable SELFIES tokens
    """
    a = sf.get_semantic_robust_alphabet()
    # remove cations/anions except oxygen anion
    to_remove = []
    for ai in a:
        if "+1" in ai:
            to_remove.append(ai)
        elif "-1" in ai:
            to_remove.append(ai)
    # remove [P],[#P],[=P]
    to_remove.extend(["[P]", "[#P]", "[=P]", "[B]", "[#B]", "[=B]"])

    a -= set(to_remove)
    a.add("[O-1]")
    return a

def run_stoned(
    start_smiles: str,
    fp_type: str = "ECFP4",
    num_samples: int = 2000,
    max_mutations: int = 2,
    min_mutations: int = 1,
    alphabet: Union[List[str], Set[str]] = None,
    return_selfies: bool = False,
    _pbar: Any = None,
) -> Union[Tuple[List[str], List[float]], Tuple[List[str], List[str], List[float]]]:
    """
    Execute the STONED (Stochastic Organic Electronic Nuclear Degrees) SELFIES algorithm 
    to generate a set of chemically similar molecules to the input molecule by applying 
    stochastic mutations.

    :param start_smiles: The SMILES string representation of the starting molecule.
    :param fp_type: The type of fingerprint to use for molecular similarity scoring.
    :param num_samples: The total number of molecules to generate.
    :param max_mutations: The maximum number of mutations to apply to each molecule.
    :param min_mutations: The minimum number of mutations to apply to each molecule.
    :param alphabet: A set of characters representing chemical substructures to use in mutations.
    :param return_selfies: Boolean indicating whether to return molecules in SELFIES format.
    :return: Lists of generated molecules in SELFIES and/or SMILES format and their similarity scores.
    """

    # Initialize the alphabet with basic chemically interpretable characters if not provided
    if alphabet is None:
        alphabet = get_basic_alphabet()

    # Ensure the alphabet is in list format
    alphabet = list(alphabet) if isinstance(alphabet, set) else alphabet

    # Generate list of integers representing mutation levels
    num_mutation_ls = list(range(min_mutations, max_mutations + 1))

    # Convert input SMILES string to RDKit Mol object
    start_mol = rdkit.Chem.MolFromSmiles(start_smiles)
    if start_mol is None:
        raise ValueError("Invalid SMILES string provided for the starting molecule.")

    # Generate randomized SMILES strings from the input SMILES
    randomized_smile_orderings = [
        stoned.randomize_smiles(rdkit.Chem.MolFromSmiles(start_smiles))
        for _ in range(num_samples // len(num_mutation_ls))
    ]

    # Convert randomized SMILES strings to SELFIES format
    selfies_ls = [sf.encoder(x) for x in randomized_smile_orderings]

    # Lists to collect mutated molecules in SMILES and SELFIES format
    all_smiles_collect = []
    all_selfies_collect = []

    # Apply mutations to each molecule
    for num_mutations in num_mutation_ls:
        # Mutate molecules in SELFIES format
        selfies_mut = stoned.get_mutated_SELFIES(
            selfies_ls.copy(), num_mutations=num_mutations, alphabet=alphabet
        )

        # Convert mutated molecules back to SMILES format
        smiles_back = [sf.decoder(x) for x in selfies_mut]

        # Append to collection lists
        all_smiles_collect.extend(smiles_back)
        all_selfies_collect.extend(selfies_mut)

        # Update progress bar if provided
        if _pbar:
            _pbar.set_description(f"ðŸ¥ŒSTONEDðŸ¥Œ Mutations: {num_mutations}")
            _pbar.update(len(smiles_back))

    # Progress bar update for filtering step
    if _pbar:
        _pbar.set_description(f"ðŸ¥ŒSTONEDðŸ¥Œ Filtering")

        # Filter out duplicates by checking canonicalized SMILES strings
        all_mols = [rdkit.Chem.MolFromSmiles(s) for s in all_smiles_collect]
        all_canon = [stoned.largest_mol(rdkit.Chem.MolToSmiles(m, canonical=True)) if m else None for m in all_mols]
        seen = set()
        to_keep = [False for _ in all_canon]
        for i in range(len(all_canon)):
            if all_canon[i] and all_canon[i] not in seen:
                to_keep[i] = True
                seen.add(all_canon[i])

    # Use boolean flags to keep only unique molecules
    filter_mols = [m for i, m in enumerate(all_mols) if to_keep[i]]
    filter_selfies = [s for i, s in enumerate(all_selfies_collect) if to_keep[i]]
    filter_smiles = [s for i, s in enumerate(all_smiles_collect) if to_keep[i]]

    # Compute similarity scores using Tanimoto similarity on the fingerprints of molecules
    base_fp = stoned.get_fingerprint(start_mol, fp_type=fp_type)
    fps = [stoned.get_fingerprint(m, fp_type) for m in filter_mols]
    scores = BulkTanimotoSimilarity(base_fp, fps)

    # Return results in SELFIES format if requested, otherwise return in SMILES format
    if return_selfies:
        return filter_selfies, filter_smiles, scores
    else:
        return filter_smiles, scores
